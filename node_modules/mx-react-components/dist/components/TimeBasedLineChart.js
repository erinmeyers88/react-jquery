'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');
var ReactDom = require('react-dom');
var Radium = require('radium');

var d3 = require('d3');
var moment = require('moment');
var numeral = require('numeral');

var StyleConstants = require('../constants/Style');

var TimeBasedLineChart = (function (_React$Component) {
  _inherits(TimeBasedLineChart, _React$Component);

  function TimeBasedLineChart(props) {
    _classCallCheck(this, TimeBasedLineChart);

    _get(Object.getPrototypeOf(TimeBasedLineChart.prototype), 'constructor', this).call(this, props);

    var adjustedWidth = this.props.width - this.props.margin.right - this.props.margin.left;
    var adjustedHeight = this.props.height - this.props.margin.top - this.props.margin.bottom;

    this.state = {
      adjustedHeight: adjustedHeight,
      adjustedWidth: adjustedWidth
    };
  }

  _createClass(TimeBasedLineChart, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        chartEl: ReactDom.findDOMNode(this.refs.chart)
      });
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      if (newProps.height !== null || newProps.width !== null || newProps.margin !== null) {
        var height = newProps.height || this.props.height;
        var width = newProps.width || this.props.width;
        var margin = newProps.margin || this.props.margin;

        var adjustedWidth = width - margin.right - margin.left;
        var adjustedHeight = height - margin.top - margin.bottom;

        this.setState({
          adjustedHeight: adjustedHeight,
          adjustedWidth: adjustedWidth
        });
      }
    }
  }, {
    key: '_getAreaBelowZero',
    value: function _getAreaBelowZero(data) {
      var _this = this;

      var area = d3.svg.area().x(function (d) {
        var currentDate = moment.unix(d.timeStamp).startOf(_this.props.rangeType).unix();

        return _this._getXScaleValue(currentDate);
      }).y0(this.state.adjustedHeight - 10).y1(this._getYScaleValue(0));

      return area(data);
    }
  }, {
    key: '_getFlatLine',
    value: function _getFlatLine(data) {
      var _this2 = this;

      var flatLine = d3.svg.line().x(function (d) {
        var currentDate = moment.unix(d.timeStamp).startOf(_this2.props.rangeType).unix();

        return _this2._getXScaleValue(currentDate);
      }).y(this.state.adjustedHeight);

      return flatLine(data);
    }
  }, {
    key: '_getLine',
    value: function _getLine(data) {
      var _this3 = this;

      var line = d3.svg.line().x(function (d) {
        var currentDate = moment.unix(d.timeStamp).startOf(_this3.props.rangeType).unix();

        return _this3._getXScaleValue(currentDate);
      }).y(function (d) {
        return _this3._getYScaleValue(d.value);
      });

      return line(data);
    }
  }, {
    key: '_getSliceMiddle',
    value: function _getSliceMiddle() {
      return this._getSliceWidth() / 2;
    }
  }, {
    key: '_getSliceWidth',
    value: function _getSliceWidth() {
      return Math.floor(this.state.adjustedWidth / this.props.data.length);
    }
  }, {
    key: '_getSplitData',
    value: function _getSplitData() {
      var _this4 = this;

      var future = [];
      var past = [];

      this.props.data.forEach(function (item) {
        var currentDate = moment.unix(item.timeStamp).startOf(_this4.props.rangeType);

        if (currentDate.isBefore(moment.unix(_this4.props.breakPointDate), _this4.props.rangeType)) {
          past.push(item);
        }

        if (currentDate.isAfter(moment.unix(_this4.props.breakPointDate), _this4.props.rangeType)) {
          future.push(item);
        }

        if (currentDate.isSame(moment.unix(_this4.props.breakPointDate), _this4.props.rangeType)) {
          past.push(item);
          future.push(item);
        }
      });

      return [past, future];
    }
  }, {
    key: '_getYAxisTicks',
    value: function _getYAxisTicks(data) {
      var numTicks = arguments.length <= 1 || arguments[1] === undefined ? 4 : arguments[1];

      var maxValue = d3.max(this.props.data, function (d) {
        var value = d.above ? d.value + d.above : d.value + 1000;
        var multiplier = value < 0 ? -1000 : 1000;

        return Math.ceil(value / multiplier) * multiplier;
      });

      var minValue = d3.min(this.props.data, function (d) {
        var value = d.below ? d.value + d.below : d.value - 1000;
        var multiplier = value < 0 ? -1000 : 1000;

        return Math.ceil(value / multiplier) * multiplier;
      });

      minValue = minValue > 0 ? 0 : minValue;

      var ticks = [maxValue, minValue];
      var interval = (maxValue - minValue) / numTicks;

      for (var current = minValue; current < maxValue; current += interval) {
        ticks.push(current);
      }

      if (this.props.alwaysShowZeroYTick) {
        if (ticks.indexOf(0) === -1) {
          var shouldAddZeroToTicks = true;

          ticks.forEach(function (tick) {
            if (tick <= 1000 && tick > 0 || tick >= -1000 && tick < 0) {
              shouldAddZeroToTicks = false;
            }
          });

          if (shouldAddZeroToTicks) {
            ticks.push(0);
          }
        }
      }

      return ticks;
    }
  }, {
    key: '_getXScaleFunction',
    value: function _getXScaleFunction() {
      var maxDate = this.props.data[this.props.data.length - 1].timeStamp;
      var minDate = this.props.data[0].timeStamp;

      maxDate = moment.unix(maxDate).endOf(this.props.rangeType).unix();
      minDate = moment.unix(minDate).startOf(this.props.rangeType).unix();

      return d3.time.scale().range([0, this.state.adjustedWidth]).domain([minDate, maxDate]);
    }
  }, {
    key: '_getXScaleValue',
    value: function _getXScaleValue(value) {
      var xScale = this._getXScaleFunction();

      return xScale(value);
    }
  }, {
    key: '_getYScaleFunction',
    value: function _getYScaleFunction() {
      var maxValue = d3.max(this.props.data, function (d) {
        var value = d.above ? d.value + d.above : d.value + 1000;
        var multiplier = value < 0 ? -1000 : 1000;

        return Math.ceil(value / multiplier) * multiplier;
      });

      var minValue = d3.min(this.props.data, function (d) {
        var value = d.below ? d.value + d.below : d.value - 1000;
        var multiplier = value < 0 ? -1000 : 1000;

        return Math.ceil(value / multiplier) * multiplier;
      });

      minValue = minValue > 0 ? 0 : minValue;

      return d3.scale.linear().range([this.state.adjustedHeight, 0]).domain([minValue, maxValue]);
    }
  }, {
    key: '_getYScaleValue',
    value: function _getYScaleValue(value) {
      var yScale = this._getYScaleFunction();

      return yScale(value) - 10;
    }
  }, {
    key: '_renderChart',
    value: function _renderChart() {
      var data = this.props.data;

      this._renderChartBase();

      if (data.length > 0) {
        this._renderLineChart();
      }
    }
  }, {
    key: '_renderChartBase',
    value: function _renderChartBase() {
      var margin = this.props.margin;
      var width = this.props.width;
      var height = this.props.height;
      var chart = d3.select(this.state.chartEl);
      var data = this.props.data;

      chart.style(styles.svg);

      chart.selectAll('g').remove();

      chart.attr('width', width).attr('height', height);

      if (data.length > 0) {
        chart.append('g').attr('class', 'x-axis').attr('transform', 'translate(' + (margin.left - this._getSliceMiddle()) + ',' + (height - margin.bottom) + ')');

        chart.append('g').attr('class', 'y-axis').attr('transform', 'translate(' + (margin.left + 20) + ',' + (margin.top - 10) + ')');

        chart.append('g').attr('class', 'grid-line').attr('transform', 'translate(' + (margin.left - this._getSliceMiddle()) + ',' + (margin.top - 10) + ')');
      } else {
        chart.append('g').append('text').attr('transform', 'translate(' + (width / 2 - 37) + ',' + height / 2.5 + ')').text('No data found.');
      }

      chart.on('mouseleave', this._handleChartMouseLeave.bind(this));
    }
  }, {
    key: '_renderLineChart',
    value: function _renderLineChart() {
      var _this5 = this;

      var chart = d3.select(this.state.chartEl);
      var data = this._getSplitData();
      var xAxisFormat = this.props.rangeType === 'day' ? 'MMM D' : 'MMM';
      var yTicks = this._getYAxisTicks(this.props.data);

      //Draw the xAxis labels
      var xAxis = d3.svg.axis().scale(this._getXScaleFunction()).orient('bottom').tickFormat(function (d) {
        return moment.unix(d).format(xAxisFormat);
      }).ticks(8);

      //Draw the yAxis labels
      var yAxis = d3.svg.axis().scale(this._getYScaleFunction()).orient('left').tickValues(yTicks).tickFormat(this.props.yAxisFormatter);

      //Draw the horizontal grid lines
      var yGrid = d3.svg.axis().scale(this._getYScaleFunction()).orient('left').tickValues(yTicks).tickSize(-this.state.adjustedWidth, 0, 0).tickFormat('');

      //Add the groups
      data.forEach(function (dataSet, i) {
        var color = _this5.props.lineColor;
        var breakPointDate = moment.unix(_this5.props.breakPointDate);
        var isDayRangeType = _this5.props.rangeType === 'day';
        var isPast = i === 0;

        var group = chart.append('g').attr('class', 'group').attr('transform', 'translate(' + _this5.props.margin.left + ',' + _this5.props.margin.top + ')');

        //Lines ================================
        var dash = !isPast && _this5.props.dashedFutureLine ? '2, 2' : 'none';

        var lineGroup = group.append('g').attr('class', 'line-group');

        lineGroup.append('svg:path').attr('class', 'mx-time-based-line-chart-line').attr('stroke', color).attr('stroke-width', '2px').attr('stroke-dasharray', dash).attr('fill', 'none').attr('d', _this5._getLine(dataSet));

        //Area Below 0 ================
        if (_this5.props.shadeAreaBelowZero) {
          var belowZeroGroup = lineGroup.append('g').attr('class', 'above-area-group');

          belowZeroGroup.append('svg:path').attr('class', 'mx-time-based-line-chart-below-zero-area').attr('stroke-width', '0').attr('fill', _this5.props.areaBelowZeroColor).attr('opacity', '0.1').attr('d', _this5._getAreaBelowZero(dataSet));
        }

        //Break Point date, line, and label ===========
        if (_this5.props.showBreakPoint) {
          var breakPointGroup = lineGroup.append('g').attr('class', 'break-point-group');

          var breakPoint = breakPointGroup.selectAll('.break-point-group').data(dataSet);

          var newBreakPoint = breakPoint.enter();

          //Break point label
          newBreakPoint.append('text').attr('class', 'mx-time-based-line-chart-break-point-label').attr('x', function (d) {
            var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();
            var offSet = isDayRangeType ? 18 : 25;

            return _this5._getXScaleValue(currentDate) - offSet;
          }).attr('y', -18).attr('opacity', function (d) {
            var currentDate = moment.unix(d.timeStamp).format('YYYY MM DD');
            var isSameDateAsBreakPoint = currentDate === breakPointDate.format('YYYY MM DD');

            return isSameDateAsBreakPoint && i === 1 ? '1' : '0';
          }).text(_this5.props.breakPointLabel);

          if (!_this5.props.staticXAxis) {
            //Break point date
            newBreakPoint.append('text').attr('class', 'mx-time-based-line-chart-break-point-date').attr('x', function (d) {
              var offSet = isDayRangeType ? 18 : 22;
              var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

              return _this5._getXScaleValue(currentDate) - offSet;
            }).attr('y', _this5.state.adjustedHeight + 20).attr('opacity', function (d) {
              var currentDate = moment.unix(d.timeStamp).format('YYYY MM DD');
              var isSameDateAsBreakPoint = currentDate === breakPointDate.format('YYYY MM DD');

              return isSameDateAsBreakPoint && i === 1 ? '1' : '0';
            }).text(function (d) {
              var dateFormat = isDayRangeType ? 'MMM D' : 'MMMM';
              var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

              return moment.unix(currentDate).format(dateFormat);
            });
          }

          //Break point line
          newBreakPoint.append('line').attr('class', 'mx-time-based-line-chart-break-point-line').attr('x1', function (d) {
            var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

            return _this5._getXScaleValue(currentDate);
          }).attr('y1', -10).attr('x2', function (d) {
            var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

            return _this5._getXScaleValue(currentDate);
          }).attr('y2', _this5.state.adjustedHeight - 10).style('stroke-width', 1).style('stroke', '#555').style('fill', 'none').style('opacity', function (d) {
            var currentDate = moment.unix(d.timeStamp).format('YYYY MM DD');
            var isSameDateAsBreakPoint = currentDate === breakPointDate.format('YYYY MM DD');

            return isSameDateAsBreakPoint && !isPast ? '0.2' : '0';
          });
        }

        //Dots =================================
        var dotGroup = lineGroup.append('g').attr('class', 'dot-group');

        var dots = dotGroup.selectAll('.dot').data(dataSet);

        var newDots = dots.enter();

        newDots.append('circle').attr('class', 'mx-time-based-line-chart-dot').attr('cx', function (d) {
          var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

          return _this5._getXScaleValue(currentDate);
        }).attr('cy', function (d) {
          return _this5._getYScaleValue(d.value);
        }).attr('r', 3).attr('opacity', function (d, j) {
          var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType);
          var isBreakPointDate = currentDate.format('YYYY MM DD') === breakPointDate.format('YYYY MM DD');
          var isStartOfSet = j === 0;
          var isEndOfSet = j === dataSet.length - 1;

          if (isStartOfSet && isPast || isBreakPointDate && _this5.props.showBreakPoint && !isPast || isEndOfSet && !isPast) {
            return '1';
          }

          return '0';
        }).style('fill', '#fff').style('stroke', color).style('stroke-width', '2px');

        //Slice ================================
        var sliceGroup = lineGroup.append('g').attr('class', 'slice-group');

        var slices = sliceGroup.selectAll('.slice-group').data(dataSet);

        var newSlices = slices.enter();

        newSlices.append('rect').attr('class', 'slice').attr('x', function (d) {
          var currentDate = moment.unix(d.timeStamp).startOf(_this5.props.rangeType).unix();

          return _this5._getXScaleValue(currentDate) - _this5._getSliceMiddle();
        }).attr('y', -10).attr('height', _this5.state.adjustedHeight).attr('width', _this5._getSliceWidth()).style('opacity', '0').style('display', function (d) {
          var currentDate = moment.unix(d.timeStamp);
          var isBreakPointDate = currentDate.format('YYYY MM DD') === breakPointDate.format('YYYY MM D');

          return isPast && isBreakPointDate ? 'none' : 'block';
        }).on('mouseover', _this5._handleDataPointMouseOver.bind(_this5));
      });

      //Update the axes
      chart.selectAll('g.grid-line').call(yGrid);
      chart.select('g.y-axis').call(yAxis);

      if (this.props.staticXAxis) {
        chart.select('g.x-axis').call(xAxis);
      }

      //Style xAxis labels
      chart.select('g.x-axis').selectAll('text').style('text-anchor', function () {
        return 'middle';
      });

      chart.select('g.y-axis').selectAll('text').style('text-anchor', 'start').attr('transform', 'translate(-60, 0)');

      //Style rest of chart elements
      chart.selectAll('text').style(styles.text);
      chart.selectAll('.domain').style(styles.domain);
      chart.selectAll('.grid-line .tick').style(styles.gridLineTick);
    }
  }, {
    key: '_handleDataPointMouseOver',
    value: function _handleDataPointMouseOver(d) {
      var graphMiddleTimeStamp = this.props.data[Math.floor(this.props.data.length / 2)].timeStamp;
      var graphMiddleDate = moment.unix(graphMiddleTimeStamp).startOf(this.props.rangeType);
      var currentDate = moment.unix(d.timeStamp).startOf(this.props.rangeType);
      var isAfterMidPoint = currentDate.isAfter(graphMiddleDate);
      var sliceWidth = this._getSliceMiddle();
      var xScale = this._getXScaleValue(currentDate.unix());

      var left = isAfterMidPoint ? 'auto' : xScale + this.props.margin.left + sliceWidth + 10;
      var right = isAfterMidPoint ? this.state.adjustedWidth + this.props.margin.right + sliceWidth + 10 - xScale : 'auto';
      var textAlign = isAfterMidPoint ? 'right' : 'left';
      var top = this.props.children ? this._getYScaleValue(d.value) - 5 + this.props.margin.top : this._getYScaleValue(d.value) - 5;

      var position = {
        left: left,
        right: right,
        textAlign: textAlign,
        top: top
      };

      this.setState({
        hoveredData: d,
        tooltipPosition: position
      });

      this.props.onDataPointHover(d);
    }
  }, {
    key: '_handleChartMouseLeave',
    value: function _handleChartMouseLeave() {
      this.setState({
        hoveredData: false,
        tooltipPosition: false
      });

      this._removeSvgTooltipComponents();
    }
  }, {
    key: '_removeSvgTooltipComponents',
    value: function _removeSvgTooltipComponents() {
      var dots = d3.select(this.state.chartEl).selectAll('.dot-group');
      var slices = d3.select(this.state.chartEl).selectAll('.slice-group');

      slices.selectAll('.mx-time-based-line-chart-hover-rectangle').remove();
      dots.selectAll('.mx-time-based-line-chart-hover-above').remove();
      dots.selectAll('.mx-time-based-line-chart-hover-below').remove();
      dots.selectAll('.mx-time-based-line-chart-hover-dot').remove();
    }
  }, {
    key: '_renderSvgTooltipComponents',
    value: function _renderSvgTooltipComponents() {
      var _this6 = this;

      var hoveredData = this.state.hoveredData;

      var breakPointDate = moment.unix(this.props.breakPointDate);
      var currentDate = moment.unix(hoveredData.timeStamp).startOf(this.props.rangeType);

      var dash = currentDate.isAfter(breakPointDate) && this.props.dashedFutureLine ? '2, 2' : 'none';
      var isBreakPointDate = currentDate.format('MM DD YYYY') === breakPointDate.format('MM DD YYYY');
      var isDayRangeType = this.props.rangeType === 'day';
      var dateFormat = isDayRangeType ? 'MMM D' : 'MMM';

      var dots = d3.select(this.state.chartEl).selectAll('.dot-group');
      var slices = d3.select(this.state.chartEl).selectAll('.slice-group');

      //Gray rectangle highlighting hovered section
      slices.append('rect').attr('class', 'mx-time-based-line-chart-hover-rectangle').attr('x', function () {
        return _this6._getXScaleValue(currentDate.unix()) - _this6._getSliceMiddle();
      }).attr('y', -10).attr('height', this.state.adjustedHeight).attr('width', this._getSliceWidth()).style('opacity', '0.025');

      if (!this.props.staticXAxis) {
        //Date Text
        slices.append('text').attr('x', function () {
          var offSet = _this6.props.rangeType === 'day' ? 17 : 10;

          return _this6._getXScaleValue(currentDate.unix()) - offSet;
        }).attr('y', this.state.adjustedHeight + 5).style('font-size', '12').style('opacity', '0.3').text(function () {
          return isBreakPointDate ? null : currentDate.format(dateFormat);
        });
      }

      //Credit balance line
      if (hoveredData.above) {
        dots.append('line').attr('class', 'mx-time-based-line-chart-hover-above').attr('x1', this._getXScaleValue(currentDate.unix())).attr('y1', this._getYScaleValue(hoveredData.value + hoveredData.above)).attr('x2', this._getXScaleValue(currentDate.unix())).attr('y2', this._getYScaleValue(hoveredData.value)).style('stroke-dasharray', dash).style('stroke-width', 3).style('stroke', '#30B53C').style('fill', 'none');
      }

      //Debit balance line
      if (hoveredData.below) {
        var below = hoveredData.value + hoveredData.below;
        var belowValue = below < -4000 ? below + 500 : below;

        dots.append('line').attr('class', 'mx-time-based-line-chart-hover-below').attr('x1', this._getXScaleValue(currentDate.unix())).attr('y1', this._getYScaleValue(hoveredData.value)).attr('x2', this._getXScaleValue(currentDate.unix())).attr('y2', this._getYScaleValue(belowValue)).style('stroke-dasharray', dash).style('stroke-width', 3).style('stroke', '#C93030').style('fill', 'none');
      }

      //Circle on line
      dots.append('circle').attr('class', 'mx-time-based-line-chart-hover-dot').attr('cx', this._getXScaleValue(currentDate.unix())).attr('cy', this._getYScaleValue(hoveredData.value)).attr('r', 3).style('fill', '#fff').style('stroke', this.props.lineColor).style('stroke-width', '2px');
    }
  }, {
    key: '_renderTooltip',
    value: function _renderTooltip() {
      if (this.props.showTooltips && this.state.tooltipPosition) {
        var hoveredData = this.state.hoveredData;
        var position = this.state.tooltipPosition;

        this._renderSvgTooltipComponents();

        if (this.props.children) {
          return React.createElement(
            'div',
            { className: 'mx-time-based-line-chart-tool-tip-wrapper', style: [styles.tooltipWrapper, position] },
            this.props.children
          );
        }

        return React.createElement(
          'div',
          { style: [styles.tooltipWrapper, position] },
          React.createElement(
            'div',
            { style: styles.defaultToolTip },
            hoveredData.value
          )
        );
      }
    }
  }, {
    key: 'render',
    value: function render() {
      this._renderChart();

      return React.createElement(
        'div',
        { className: 'mx-time-based-line-chart', style: [styles.component, { height: this.props.height + 'px', width: this.props.width + 'px' }, this.props.style] },
        this._renderTooltip(),
        React.createElement('svg', { className: 'mx-time-based-line-chart-svg', ref: 'chart' })
      );
    }
  }]);

  return TimeBasedLineChart;
})(React.Component);

var styles = {
  component: {
    fontFamily: StyleConstants.FontFamily,
    padding: '10px',
    position: 'relative',
    boxSizing: 'content-box'
  },
  credit: {
    backgroundColor: '#30B53C'
  },
  debit: {
    backgroundColor: '#C93030'
  },
  defaultToolTip: {
    backgroundColor: StyleConstants.Colors.PRIMARY,
    color: '#FFFFFF',
    padding: '3px 5px 3px 5px',
    transform: 'translateY(32px)'
  },
  domain: {
    opacity: 0
  },
  gridLineTick: {
    'stroke': '#ccc',
    'opacity': 1,
    'stroke-width': '0.5px'
  },
  svg: {
    'display': 'block',
    'height': '100%',
    'position': 'relative',
    'width': '100%'
  },
  text: {
    'fill': '#999',
    'font-size': '12px',
    'font-weight': 'normal'
  },
  tooltip: {
    color: '#FFF',
    display: 'inline-block',
    fontSize: '11px',
    marginBottom: '3px',
    marginTop: '3px',
    minWidth: '50px',
    padding: '5px'
  },
  tooltipWrapper: {
    display: 'inline-block',
    position: 'absolute',
    zIndex: '1'
  }
};

TimeBasedLineChart.propTypes = {
  alwaysShowZeroYTick: React.PropTypes.bool,
  areaBelowZeroColor: React.PropTypes.string,
  breakPointDate: React.PropTypes.number,
  breakPointLabel: React.PropTypes.string,
  children: React.PropTypes.node,
  dashedFutureLine: React.PropTypes.bool,
  data: React.PropTypes.array,
  height: React.PropTypes.number,
  lineColor: React.PropTypes.string,
  margin: React.PropTypes.object,
  onDataPointHover: React.PropTypes.func,
  rangeType: React.PropTypes.oneOf(['day', 'month']),
  shadeAreaBelowZero: React.PropTypes.bool,
  showBreakPoint: React.PropTypes.bool,
  showTooltips: React.PropTypes.bool,
  staticXAxis: React.PropTypes.bool,
  width: React.PropTypes.number,
  yAxisFormatter: React.PropTypes.func
};

TimeBasedLineChart.defaultProps = {
  alwaysShowZeroYTick: false,
  areaBelowZeroColor: StyleConstants.Colors.RED,
  breakPointDate: moment().startOf('day').unix(),
  breakPointLabel: 'Today',
  dashedFutureLine: true,
  data: [],
  height: 400,
  lineColor: StyleConstants.Colors.PRIMARY,
  margin: { top: 30, right: 50, bottom: 20, left: 50 },
  onDataPointHover: function onDataPointHover() {},
  rangeType: 'day',
  shadeAreaBelowZero: false,
  showBreakPoint: true,
  showTooltips: true,
  staticXAxis: true,
  width: 550,
  yAxisFormatter: function yAxisFormatter(d) {
    return numeral(d).format('0a');
  }
};

module.exports = Radium(TimeBasedLineChart);